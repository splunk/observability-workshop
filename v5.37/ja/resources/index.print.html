<!doctype html><html lang=ja dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.119.0"><meta name=generator content="Relearn 5.23.2+tip"><meta name=description content="Splunk Observability Workshops"><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="その他のリソース :: Splunk Observability Cloud Workshops"><meta name=twitter:description content="Splunk Observability Workshops"><meta property="og:title" content="その他のリソース :: Splunk Observability Cloud Workshops"><meta property="og:description" content="Splunk Observability Workshops"><meta property="og:type" content="website"><meta property="og:url" content="https://splunk.github.io/observability-workshop/v5.37/ja/resources/index.html"><meta property="og:site_name" content="Splunk Observability Cloud Workshops"><title>その他のリソース :: Splunk Observability Cloud Workshops</title><link href=https://splunk.github.io/observability-workshop/v5.37/en/resources/index.html rel=alternate hreflang=x-default><link href=https://splunk.github.io/observability-workshop/v5.37/en/resources/index.html rel=alternate hreflang=en><link href=https://splunk.github.io/observability-workshop/v5.37/ja/resources/index.html rel=alternate hreflang=ja><link href=https://splunk.github.io/observability-workshop/v5.37/ja/resources/index.html rel=canonical type=text/html title="その他のリソース :: Splunk Observability Cloud Workshops"><link href=../../ja/resources/index.xml rel=alternate type=application/rss+xml title="その他のリソース :: Splunk Observability Cloud Workshops"><link href=../../images/favicon.ico?1704475206 rel=icon type=image/x-icon sizes=any><link href=../../css/fontawesome-all.min.css?1704475207 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fontawesome-all.min.css?1704475207 rel=stylesheet></noscript><link href=../../css/nucleus.css?1704475207 rel=stylesheet><link href=../../css/auto-complete.css?1704475207 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/auto-complete.css?1704475207 rel=stylesheet></noscript><link href=../../css/perfect-scrollbar.min.css?1704475207 rel=stylesheet><link href=../../css/fonts.css?1704475207 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fonts.css?1704475207 rel=stylesheet></noscript><link href=../../css/theme.css?1704475207 rel=stylesheet><link href=../../css/theme-splunk-light.css?1704475207 rel=stylesheet id=R-variant-style><link href=../../css/variant.css?1704475207 rel=stylesheet><link href=../../css/print.css?1704475207 rel=stylesheet media=print><link href=../../css/format-print.css?1704475207 rel=stylesheet><link href=../../css/ie.css?1704475207 rel=stylesheet><script src=../../js/url.js?1704475207></script>
<script src=../../js/variant.js?1704475207></script>
<script>window.index_js_url="../../ja/index.search.js";var root_url="../../",baseUri=root_url.replace(/\/$/,"");window.relearn=window.relearn||{},window.relearn.baseUriFull="https://splunk.github.io/observability-workshop/v5.37/",window.variants&&variants.init(["splunk-light","splunk-dark"]),window.T_Copy_to_clipboard=`クリップボードにコピー`,window.T_Copied_to_clipboard=`クリップボードにコピー!`,window.T_Copy_link_to_clipboard=`リンクをクリップボードにコピー`,window.T_Link_copied_to_clipboard=`リンクをクリップボードにコピーしました!`,window.T_Reset_view=`ビューのリセット`,window.T_View_reset=`リセットを見る`,window.T_No_results_found=`"{0}" の結果が見つかりません`,window.T_N_results_found=`"{0}" で {1} 件の結果が見つかりました`</script><script src=https://cdn.signalfx.com/o11y-gdi-rum/latest/splunk-otel-web.js crossorigin=anonymous></script>
<script src=https://cdn.signalfx.com/o11y-gdi-rum/latest/splunk-otel-web-session-recorder.js crossorigin=anonymous></script>
<script>SplunkRum.init({beaconUrl:"https://rum-ingest.eu0.signalfx.com/v1/rum",rumAuth:"EDIbCJR4LlxWdXMLjkYX1g",app:"observability-workshop",version:"1",environment:"observability-workshop-env"}),SplunkSessionRecorder.init({beaconUrl:"https://rum-ingest.eu0.signalfx.com/v1/rumreplay",rumAuth:"EDIbCJR4LlxWdXMLjkYX1g"})</script><style>@media screen and (min-width:1000px){#R-body .flex-block-wrapper{margin-left:auto;margin-right:auto;max-width:1400px;width:100%}}:root{--MENU-WIDTH-L:21rem}</style></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=../../ja/resources/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="メニュー (CTRL+ALT+n)">
<i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../ja/index.html><span itemprop=name>Splunk Observability Workshops</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>その他のリソース</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=その他のリソース>その他のリソース</h1><div class="children children-h3 children-sort-"><h3><a href=../../ja/resources/faq/index.html>よくある質問とその回答</a></h3><p>オブザーバビリティ、DevOps、インシデント対応、Splunk On-Callに関連する一般的な質問とその回答を集めました。</p><h3><a href=../../ja/resources/dimensions_properties_tags/index.html>ディメンション、プロパティ、タグ</a></h3><p>ディメンションとプロパティの比較で、どちらかを使うべきかというのはよく議論されます。</p><h3><a href=../../ja/resources/otel_tagging/index.html>OpenTelemetryとSplunkにおける、タグ付けのための命名規則</a></h3><p>大規模な組織で OpenTelemetry を展開する際には、タグ付けのための標準化された命名規則を定義し、規則が遵守されるようにガバナンスプロセスを確立することが重要です。</p></div><footer class=footline></footer></article><section><h1 class=a11y-only>その他のリソースのサブセクション</h1><article class=default><header class=headline></header><h1 id=よくある質問とその回答>よくある質問とその回答</h1><p>オブザーバビリティ、DevOps、インシデント対応、Splunk On-Callに関連する一般的な質問とその回答を集めました。</p><h2 id=q-アラートとインシデント対応インシデント管理の違いは>Q: アラートとインシデント対応、インシデント管理の違いは？</h2><p>A: アラート、インシデント対応、インシデント管理は関連する機能です。これらは一緒にインシデント対応および解決プロセスを構成します。</p><p>モニタリングやオブザーバビリティのツールはインシデント対応プラットフォームにアラートを送信します。これらのプラットフォームはアラートのコレクションを収集し、それらをインシデントとして相関させます。</p><p>これらのインシデントは記録のためにインシデント管理（ITSM）プラットフォームに記録されます。アラートは何かが起こったことを示すトリガーであり、インシデントへのコンテキストを提供します。</p><p>インシデントには、アラートの内容、インシデントが作成されてから関連するすべての活動、およびフォローされるオンコールポリシーが含まれます。ITSMは、インシデントがアクティブであるときおよび解決された後のインシデントを記録するシステムです。</p><p>インシデント対応および管理をより良く実践するために、これらのコンポーネントが必要になります。</p><span class="btn cstyle transparent"><button type=button>
On-Call</button></span><h2 id=q-オブザーバビリティはモニタリングとは違うものですか>Q: オブザーバビリティはモニタリングとは違うものですか？</h2><p>A: モニタリングとオブザーバビリティの主な違いは、「既知の未知」と「未知の未知」の違いです。</p><p>モニタリングでは、オペレーターは通常、システムのアーキテクチャと要素に関する事前の知識を持っています。彼らは要素間の関係とそれに関連するメタデータを確実に予測することができます。モニタリングは、頻繁に変更されない状態のインフラストラクチャに適しています。</p><p>オブザーバビリティは、オペレーターがシステム内のすべての要素とそれらの関係を予測し、追跡する能力が限定されているシステム向けです。</p><p>オブザーバビリティは、従来のメトリクスのモニタリングを含む一連のプラクティスと技術です。</p><p>これらのプラクティスと技術を組み合わせることで、オペレーターはシステムのすべての要素に関する事前の知識がなくても、頻繁に変更がある複雑な環境を理解することができます。オブザーバビリティ技術は、環境の変動やメタデータの変化（カーディナリティ）を従来のモニタリングよりもよく考慮できるため、より静的なモニタリングと比較して優れています。</p><span class="btn cstyle transparent"><button type=button>
Observability</button></span><h2 id=q-トレースとスパンとは何ですか>Q: トレースとスパンとは何ですか？</h2><p>A: トレースとスパンは、メトリクスとログと共に、現代のオブザーバビリティツールにフィードされるコアタイプのデータを構成します。それらは特定の要素と機能を持っていますが、一緒にうまく機能します。</p><p>マイクロサービスベースのアーキテクチャは分散しているため、システム内のトランザクションは完了する前に複数のサービスにアクセスします。これにより、問題の場所を正確に特定することが困難になります。トレースは、分散システム内のすべてのサービスを通るリクエストの完全なパスを追跡するための方法です。スパンは、各サービスでの時間のかかる操作です。トレースはスパンの結合したものであり、一緒になると個々のサービスプロセスについてより詳細な情報を提供します。メトリクスはシステムの健康状態の良いスナップショットを提供し、ログは問題を調査する際に深さを提供しますが、トレースとスパンはオペレーターに問題の源泉をより多くのコンテキストでナビゲートするのに役立ちます。これにより、インシデントの調査にかかる時間が節約され、現代のアーキテクチャの複雑さがサポートされます。</p><span class="btn cstyle transparent"><button type=button>
APM</button></span><h2 id=q-サイドカーパターンとは何ですか>Q: サイドカーパターンとは何ですか？</h2><p>A: サイドカーパターンは、関連するサービスをインフラストラクチャによって直接接続するためのデザインパターンです。関連するサービスは、接続されているアプリケーションロジックに機能を追加したりサポートしたりすることができます。これは、管理計画に関連するエージェントをアプリケーションサービスと共に展開する方法として広く使用されます。</p><p>オブザーバビリティでは、サイドカーサービスはアプリケーションロジックであり、そのサービスからデータを収集するエージェントです。このセットアップには、アプリケーションサービスを含むコンテナと、エージェントを実行するコンテナの2つが必要です。コンテナはポッドを共有し、ディスク、ネットワーク、名前空間などのリソースを共有します。また、一緒にデプロイされ、同じライフサイクルを共有します。</p><span class="btn cstyle transparent"><button type=button>
Observability</button></span><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=ディメンションプロパティタグ>ディメンション、プロパティ、タグ</h1><h2 id=メトリクスにコンテキストを与える>メトリクスにコンテキストを与える</h2><p>ディメンションとプロパティの違いや、どちらを使うべきかというのは、よく話題にされます。それぞれの説明から始めるのではなく、私たちがどのように使い、どのように似ているのかを理解してから、それぞれの違いや、なぜどちらかを使うのかの例を見ていくことにしましょう。</p><h2 id=ディメンションとプロパティの類似点>ディメンションとプロパティの類似点</h2><p>最も単純な答えは、ディメンションとプロパティはともに、メトリクスにコンテキスト（状況）を追加するメタデータの <code>key:value</code> ペアであるということです。メトリクス自体は、<code>cpu.utilization</code> のような標準的なインフラストラクチャメトリクスであろうと、API呼び出しの回数のようなカスタムメトリクスであろうと、実際に測定しているものなら全てに当てはまります。</p><p><code>cpu.utilization</code> メトリクスの値が50%であっても、それがどこから来たのかなどのコンテキストを知らなければ、それは単なる数字であり、私たちにとって有用ではありません。少なくとも、どのホストから来たのかを知る必要があります。</p><p>現在では、個々のホストのパフォーマンスや利用率よりも、クラスターやデータセンター全体のパフォーマンスや利用率をより気にすることが多く、ホストのクラスター全体の平均 <code>cpu.utilization</code>、あるホストの <code>cpu.utilization</code> が同じサービスを実行する他のホストと比べて外れ値である場合、あるいは環境間での平均 <code>cpu.utilization</code> を比較することに興味を持っています。</p><p>このように <code>cpu.utilization</code> メトリクスをスライス、集約、またはグループ化するためには、受け取る <code>cpu.utilization</code> メトリクスのメタデータに、ホストが属するクラスター、ホスト上で実行されているサービス、およびそれが属する環境などの情報が必要です。このメタデータは、ディメンションまたはプロパティの <code>key:value</code> ペアの形で存在することができます。</p><p>例えば、ダッシュボードでフィルターを適用したり、分析関数を実行する際にグループ化機能を使用したりするとき、プロパティまたはディメンションを使用することができます。</p><h2 id=ではディメンションとプロパティはどう違うの>では、ディメンションとプロパティはどう違うの？</h2><p>ディメンションはメトリクスと共に取り込み時に送信されるのに対し、プロパティは取り込み後にメトリクスやディメンションに適用されます。これは、`cpu.utilization`` の値がどのホストから来ているかのような、データポイント（メトリクスの単一の報告値）をユニークにするために必要なメタデータはディメンションでなければならないことを意味します。メトリクス名 + ディメンションは MTS（メトリクスの時間系列）をユニークに定義します。</p><p>例：特定のホスト（server1）によって送信される <code>cpu.utilization</code> メトリクスで、ディメンション <code>host:server1</code> があれば、それはユニークな時間系列と見なされます。もし 10 台のサーバーがそのメトリクスを送信していれば、メトリクス名 <code>cpu.utilization</code> を共有し、ディメンションのキー値ペア（host:server1, host:server2&mldr;host:server10）でユニークに識別される 10 の時間系列があります。</p><p>しかし、サーバー名がデータセンター内でのみユニークである場合、データセンターの場所を示す 2 番目のディメンション dc を追加する必要があります。これにより、可能な MTS の数は倍になります。受信された <code>cpu.utilization</code> メトリクスは、2 組のディメンションのキー値ペアによってユニークに識別されます。</p><p><code>cpu.utilization</code> に <code>dc:east</code> と <code>host:server1</code> を加えたものは、<code>cpu.utilization</code> に <code>dc:west</code> と <code>host:server1</code> を加えたものとは異なる時間系列を作り出します。</p><h2 id=ディメンションは不変だがプロパティは可変である>ディメンションは不変だが、プロパティは可変である</h2><p>上記で述べたように、メトリクス名 + ディメンションの組み合わせで、ユニークな MTS を作ります。したがって、ディメンションの値が変わると、メトリクス名 + ディメンション値の新しいユニークな組み合わせが生まれ、新しい MTS が作成されます。</p><p>一方、プロパティはメトリクス（またはディメンション）が取り込まれた後に適用されます。メトリクスにプロパティを適用すると、そのメトリクスが属するすべての MTS に伝播して適用されます。または、ディメンションにプロパティを適用する場合、例えば <code>host:server1</code> とすると、そのホストからのすべてのメトリクスにそのプロパティが添付されます。プロパティの値を変更すると、そのプロパティが添付されているすべての MTS のプロパティ値が更新されます。これが重要な理由は何でしょうか？ プロパティの歴史的な値にこだわる場合、それをディメンションにする必要があることを意味しています。</p><p>例：私たちはアプリケーションに関するカスタムメトリクスを収集しています。1つのメトリクスは <code>latency</code> で、アプリケーションへのリクエストのレイテンシーをカウントします。顧客ごとにレイテンシーを分類して比較できるように <code>customer</code> ディメンションを持っています。私たちは、顧客が使用しているバージョン別にアプリケーションの <code>latency</code> を分類して比較したいと考え、プロパティ <code>version</code> を <code>customer</code> ディメンションに添付しました。最初はすべての顧客がアプリケーションバージョン1を使用しているので、<code>version:1</code> です。</p><p>現在、いくつかの顧客がアプリケーションのバージョン2を使用しているため、それらの顧客に対してプロパティを <code>version:2</code> に更新します。これらの顧客の <code>version</code> プロパティの値を更新すると、その顧客に関連するすべての MTS に伝播します。これにより、これらの顧客が以前に <code>version:1</code> を使用していたという歴史が失われるため、歴史的な期間にわたって <code>version:1</code> と <code>version:2</code> の <code>latency</code> を比較する場合、正確なデータを得ることはできません。この場合、メトリクスの時間系列をユニークにするためにアプリケーションの <code>version</code> が必要ではないかもしれませんが、歴史的な値にこだわるために <code>version</code> をディメンションにする必要があります。</p><h2 id=結局いつディメンションじゃなくてプロパティを使うの>結局、いつ、ディメンションじゃなくてプロパティを使うの？</h2><p>メトリクスに添付したいメタデータがあるが、取り込み時にはそれを知らない場合が第一の理由です。第二の理由は、ベストプラクティスとして、ディメンションである必要がなければ、それをプロパティにすることです。なぜでしょうか？</p><p>一つの理由は、現在、分析ジョブやチャートレンダリングあたりの MTS の上限が 5K であり、ディメンションが多いほど多くの MTS を生成することです。プロパティは完全に自由形式であり、MTS の数を増やすことなく、メトリクスやディメンションに必要な情報を追加することができます。</p><p>ディメンションは各データポイントと共に送信されるため、ディメンションが多いほど、より多くのデータを送信することになります。これは、クラウドプロバイダーがデータ転送に料金を請求する場合、コストが高くなる可能性があります。</p><p>プロパティを使う良い例としては、ホスト情報の追加などがあります。 <code>machine_type</code>, <code>processor</code>, <code>os</code> などの情報を確認することが重要ですが、これらをディメンションとして設定し、各ホストからのすべてのメトリクスと共に送信するのではなく、プロパティとして設定し、ホストディメンションに添付することができます。</p><p>例えば <code>host:server1</code> では、プロパティ <code>machine_type:ucs</code>, <code>processor:xeon-5560</code>, <code>os:rhel71</code> を設定します。<code>host:server1</code> というディメンションを持つメトリクスが入ってくるたびに、上記のすべてのプロパティが自動的に適用されます。</p><p>プロパティの使用例としては、各サービスのエスカレーション連絡先や、各顧客の SLA レベルを知りたい場合があります。これらの項目は、メトリクスをユニークに識別するために必要ではなく、歴史的な値にも関心がないため、プロパティにすることができます。プロパティはサービスディメンションや顧客ディメンションに追加され、これらのディメンションを持つすべてのメトリクスや MTS に適用されます。</p><h2 id=タグについてはどうですか>タグについてはどうですか？</h2><p>タグは、メトリクスにコンテキストを与えたり整理するのに使われる、メタデータの 3 番目のタイプです。ディメンションやプロパティとは異なり、タグは <code>key:value</code> ペアではありません。タグはラベルやキーワードとして考えることができます。プロパティと同様に、タグは取り込み後に UI の Catalog や API を通じてプログラム的にデータに適用されます。タグはメトリクス、ディメンション、ディテクターなどの他のオブジェクトに適用することができます。</p><h2 id=タグを使う場面はどこですか>タグを使う場面はどこですか？</h2><p>タグが必要とされるのは、タグとオブジェクトの間に多対一の関係がある場合や、タグとそれに適用されるオブジェクト間に一対多の関係がある場合です。本質的に関連していないメトリクスをまとめるのに役立ちます。</p><p>例として、複数のアプリケーションを実行しているホストがある場合です。各アプリケーションに対してタグ（ラベル）を作成し、それぞれのホストに複数のタグを適用して、その上で実行されているアプリケーションをラベル付けします。</p><p>例：Server1 は 3 つのアプリケーションを実行しています。タグ <code>app1</code>, <code>app2</code>, <code>app3</code> を作成し、ディメンション <code>host:server1</code> にこれら 3 つのタグをすべて適用します。</p><p>上記の例を拡張すると、アプリケーションからのメトリクスも収集しているとします。作成したタグを、アプリケーション自体から来るメトリクスに適用することができます。タグに基づいてフィルタリングすることで、アプリケーションに基づいてフィルタリングしながら、アプリケーションと関連するホストメトリクスの全体像を得ることができます。</p><p>例：App1 は <code>service:application1</code> というディメンションでメトリクスを送信します。<code>service:application1</code> のディメンションにタグ <code>app1</code> を適用します。その後、チャートやダッシュボードでタグ <code>app1</code> でフィルタリングすることができます。</p><p>タグの他の使用例には、単一の可能な値を持つ二進状態があります。例として、カナリアテストを行い、カナリアデプロイを行った際に新しいコードを受け取ったホストをマークして、新しいコードを受け取らなかったホストとのパフォーマンスを比較しやすくすることがあります。単一の値 <code>canary</code> しかないため、<code>key:value</code> ペアは必要ありません。</p><p>ただし、タグでフィルタリングはできますが、groupBy 関数では使用できないことに注意してください。groupBy 関数は <code>key:value</code> ペアのキー部分を指定して実行され、そのキーの値に基づいて結果がグループ化されます。</p><h2 id=さらなる情報>さらなる情報</h2><p>カスタムメトリクスのディメンションを送信する方法に関する情報については、お使いのライブラリに関するクライアントライブラリのドキュメントをご覧ください。</p><p>API を通じてメトリクスやディメンションにプロパティやタグを適用する方法については、 <code>/metric/:name</code>、<code>/dimension/:key/:value</code> に関する API ドキュメントを参照してください。</p><p>UI のメタデータカタログでプロパティやタグを追加または編集する方法については、<a href=https://docs.splunk.com/Observability/metrics-and-metadata/metrics-finder-metadata-catalog.html#use-the-metadata-catalog target=_blank>Search the Metric Finder and Metadata catalog</a>で、<strong>​Add or edit metadata</strong> セクションをご覧ください。</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=opentelemetryとsplunkにおけるタグ付けのための命名規則>OpenTelemetryとSplunkにおける、タグ付けのための命名規則</h1><h2 id=はじめに>はじめに</h2><p>大規模な組織で OpenTelemetry を展開する際には、タグ付けのための標準化された命名規則を定義し、その規則が遵守されるようにガバナンスプロセスを設定することが非常に重要です。</p><p>これにより、OpenTelemetry を通じて収集される MELT データ（メトリクス、イベント、ログ、トレース）を、アラート、ダッシュボード作成、トラブルシューティングの目的で効率的に活用することが可能になります。また、Splunk Observability Cloud のユーザーが探しているデータを迅速に見つけることができます。</p><p>命名規則はまた、データを効果的に集約するためにも重要です。例えば、環境ごとのユニークなホストの数を数えたい場合、ホスト名と環境名を捉えるための標準化された規則を使用する必要があります。</p><h2 id=属性-vs-タグ>属性 vs タグ</h2><p>先に進む前に、用語についての注意をしておきましょう。OpenTelemetry の「タグ」は「属性（attribute）」と呼ばれます。属性は、手動または自動の計装を通じて、メトリクス、ログ、トレースに添付することができます。</p><p>属性はまた、<a href=https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/resourcedetectionprocessor target=_blank>Resource Detection processor</a>などのさまざまなプロセッサを使用して、OpenTelemetry コレクターレベルでメトリクス、ログ、トレースに添付することもできます。</p><p>Splunk Observability Cloud に属性付きのトレースが取り込まれると、それらは「タグ」として利用可能になります。オプションとして、トレースの一部として収集された属性は、<a href=https://docs.splunk.com/Observability/apm/span-tags/metricsets.html#troubleshooting-metricsets target=_blank>Troubleshooting Metric Sets</a>の作成に使用され、<a href=https://docs.splunk.com/Observability/apm/span-tags/tag-spotlight.html target=_blank>Tag Spotlight</a>などのさまざまな機能と共に使用することができます。</p><p>また、属性は<a href=https://docs.splunk.com/Observability/apm/span-tags/metricsets.html#monitoring-metricsets target=_blank>Monitoring Metric Sets</a>の作成に使用され、アラートのトリガーとして使用することもできます。</p><h2 id=リソースに関するセマンティック規約>リソースに関するセマンティック規約</h2><p><a href=https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions#resource-semantic-conventions target=_blank>OpenTelemetry リソースセマンティック規約</a>は、組織が標準化すべき属性を決定する際の出発点として使用できます。以下のセクションでは、よく使用される属性のいくつか見ていきましょう。</p><h3 id=サービス属性>サービス属性</h3><p>監視されるサービスを記述するために多くの属性が使用されます。</p><p><code>service.name</code> はサービスの論理名を定義する必須の属性です。OpenTelemetry SDK によって自動的に追加されますが、カスタマイズすることができます。これはシンプルに保つことが最善です（例えば、<code>inventoryservice</code> は <code>inventoryservice-prod-hostxyz</code> よりも良いでしょう。他の属性を使用してサービスの他の側面を捉えることができます）。</p><p>以下のサービス属性が推奨されます：</p><ul><li><code>service.namespace</code> はサービスを所有するチームを識別するために使用されます</li><li><code>service.instance.id</code> はサービスのユニークなインスタンスを識別するために使用されます</li><li><code>service.version</code> はサービスのバージョンを識別するために使用されます</li></ul><h3 id=テレメトリsdk>テレメトリSDK</h3><p>これらの属性はSDKによって自動的に設定され、使用されている計測ライブラリに関する情報を記録します：</p><ul><li><code>telemetry.sdk.name</code> は通常 <code>opentelemetry</code> に設定されます。</li><li><code>telemetry.sdk.language</code> は SDK の言語で、例えば <code>java</code> です。</li><li><code>telemetry.sdk.version</code> は使用されている SDK のバージョンを識別します。</li></ul><h3 id=コンテナ>コンテナ</h3><p>コンテナで実行されるサービスには、<code>container.id</code>、<code>container.name</code>、<code>container.image.name</code> など、コンテナのランタイムを記述するための多くの属性が使用されます。完全なリストは<a href=https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/container.md target=_blank>こちら</a>で確認できます。</p><h3 id=ホスト>ホスト</h3><p>これらの属性は、サービスが実行されているホストを記述し、<code>host.id</code>、<code>host.name</code>、<code>host.arch</code> などの属性を含みます。完全なリストは<a href=https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/host.md target=_blank>こちら</a>で確認できます。</p><h3 id=デプロイ環境>デプロイ環境</h3><p><code>deployment.environment</code> 属性は、サービスがデプロイされている環境（ <strong>staging</strong> や <strong>production</strong> など）を識別するために使用されます。</p><p>Splunk Observability Cloud は、この属性を使用して関連コンテンツを有効する（詳細は<a href=https://docs.splunk.com/observability/metrics-and-metadata/enablerelatedcontent.html target=_blank>こちら</a>）ため、この属性を含めることが重要です。</p><h3 id=クラウド>クラウド</h3><p>AWS などのパブリッククラウド環境で実行されるサービスに関する情報を捉えるための属性もあります。これには、<code>cloud.provider</code>、<code>cloud.account.id</code>、<code>cloud.region</code> が含まれます。</p><p>属性の完全なリストは<a href=https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/cloud.md target=_blank>こちら</a>で確認できます。</p><p>一部のクラウドプロバイダー、例えば <a href=https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/cloud_provider/gcp/README.md target=_blank>GCP</a> は、独自のセマンティック規則を定義しています。</p><h3 id=kubernetes>Kubernetes</h3><p>Kubernetesで実行されるアプリケーションにも、いくつかの標準化された属性があります。これらの多くは、Splunk の OpenTelemetry コレクター配布によって自動的に追加されます（詳細は<a href=https://docs.splunk.com/observability/metrics-and-metadata/enablerelatedcontent.html#splunk-infrastructure-monitoring target=_blank>こちら</a>）。</p><p>属性は、例えば <code>k8s.cluster.name</code>、<code>k8s.node.name</code>、<code>k8s.pod.name</code>、<code>k8s.namespace.name</code>、<code>kubernetes.workload.name</code> などがあります。</p><h2 id=カスタム属性のベストプラクティス>カスタム属性のベストプラクティス</h2><p>多くの組織では、OpenTelemetryのリソースセマンティック規約で定義されているもの以上の属性が欲しくなります。</p><p>この場合、セマンティック規約にすでに含まれている属性名との命名競合を避けることが重要です。つまり、特定の属性名を命名規則に決定する前に、セマンティック規約をチェックすると良いでしょう。</p><p>属性名の命名規則に加えて、属性値も考慮する必要があります。例えば、アプリケーションが属する特定のビジネスユニットをキャプチャしたい場合、簡単にかつ効果的にフィルタリングするために、標準化されたビジネスユニット値のリストも持ちたいでしょう。</p><p>OpenTelemetryコミュニティでは、属性の命名に従うべきガイドラインも提供しています。<a href=https://opentelemetry.io/docs/specs/otel/common/attribute-naming/ target=_blank>こちら</a>で見つけることができます。</p><p><a href=https://opentelemetry.io/docs/specs/otel/common/attribute-naming/#recommendations-for-application-developers target=_blank>Recommendations for Application Developers</a>は、私たちの議論に最も関連しています。</p><p>そこでは、以下を推奨しています：</p><ul><li><code>com.acme.shopname</code> のように、会社のドメイン名で属性名を接頭辞として付けること（属性が社内だけでなく外部で使用される可能性がある場合）</li><li>属性が特定のアプリケーションに固有であり、組織内でのみ使用される場合は、アプリケーション名で属性名に接頭辞を付けること</li><li>既存の OpenTelemetry セマンティック規約の名前を属性名の接頭辞として使用しないこと</li><li>異なる組織や業界全体で一般的なニーズがある場合は、あなたの属性名を OpenTelemetry 仕様に追加する提案を検討すること</li><li><code>otel.*</code> で始まる属性名は避けること。これは OpenTelemetry 仕様の使用に予約されています</li></ul><h2 id=カーディナリティに関する考慮事項>カーディナリティに関する考慮事項</h2><p>属性名と値の命名基準を決定する際に考慮すべき最後の点は、メトリクスのカーディナリティに関連しています。</p><p>のカーディナリティは、メトリクス名とそれに関連する次元の組み合わせによって生成されるユニークなメトリクス時系列（MTS: Metric Time Series）の数として定義されます。</p><p>メトリクスは、ディメンションの数とそれらのディメンションが持つユニークな値の数が多い場合に、高いカーディナリティを持つことになります。</p><p>例えば、あなたのアプリケーションが <code>custom.metric</code> という名前のメトリクスのデータを送信するとします。属性がない場合、<code>custom.metric</code> は単一のメトリクス時系列（MTS）を生成します。</p><p>一方で、<code>custom.metric</code>が <code>customer.id</code> という属性を含み、数千の顧客ID値がある場合、これは数千のメトリクス時系列を生成し、コストやクエリ性能に影響を与える可能性があります。</p><p>Splunk Observability Cloud は、メトリクスの使用量を管理するための<a href=https://docs.splunk.com/Observability/infrastructure/metrics-pipeline/metrics-usage-report.html target=_blank>レポート</a>を提供しています。そして、望ましくないディメンションを削除する<a href=https://docs.splunk.com/Observability/infrastructure/metrics-pipeline/use-metrics-pipeline.html target=_blank>ルール</a>を作成することができます。しかし、最初の防衛線は、属性名と値の組み合わせがどのようにメトリクスのカーディナリティを増加させるかを理解することです。</p><h2 id=まとめ>まとめ</h2><p>このドキュメントでは、大規模な OpenTelemetry インストゥルメンテーションの展開を開始する前に、OpenTelemetry タグの命名規則を定義することの重要性を強調しました。</p><p>OpenTelemetry のリソースセマンティック規約がいくつかの属性の命名規則を定義し、多くの属性が OpenTelemetry SDKや OpenTelemetry コレクター内で動作するプロセッサーを通じて自動的に収集される方法について説明しました。</p><p>最後に、リソースセマンティック規約が組織のニーズに十分でない場合に、属性名を作成するためのベストプラクティスを共有しました。</p><footer class=footline></footer></article></section></div></main></div><script src=../../js/clipboard.min.js?1704475207 defer></script>
<script src=../../js/perfect-scrollbar.min.js?1704475207 defer></script>
<script src=../../js/theme.js?1704475207 defer></script></body></html>